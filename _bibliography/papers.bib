---
---

@article{Eudine2023gateseeder,
      title={GateSeeder: Near-memory CPU-FPGA Acceleration of Short and Long Read Mapping}, 
      author={Julien Eudine and Mohammed Alser and Gagandeep Singh and Can Alkan and Onur Mutlu},
      year={2023},
      month = {sep},
      eprint={2309.17063},
      archivePrefix={arXiv},
      abstract = {Motivation: Read mapping is a computationally expensive process and a major bottleneck in genomics analyses. The performance of read mapping is mainly limited by the performance of three key computational steps: Index Querying, Seed Chaining, and Sequence Alignment. The first step is dominated by how fast and frequent it accesses the main memory (i.e., memory-bound), while the latter two steps are dominated by how fast the CPU can compute their computationally-costly dynamic programming algorithms (i.e., compute-bound). Accelerating these three steps by exploiting new algorithms and new hardware devices is essential to accelerate most genome analysis pipelines that widely use read mapping. Given the large body of work on accelerating Sequence Alignment, this work focuses on significantly improving the remaining steps. Results: We introduce GateSeeder, the first CPU-FPGA-based near-memory acceleration of both short and long read mapping. GateSeeder exploits near-memory computation capability provided by modern FPGAs that couple a reconfigurable compute fabric with high-bandwidth memory (HBM) to overcome the memory-bound and compute-bound bottlenecks. GateSeeder also introduces a new lightweight algorithm for finding the potential matching segment pairs. Using real ONT, HiFi, and Illumina sequences, we experimentally demonstrate that GateSeeder outperforms Minimap2, without performing sequence alignment, by up to 40.3x, 4.8x, and 2.3x, respectively. When performing read mapping with sequence alignment, GateSeeder outperforms Minimap2 by 1.15-4.33x (using KSW2) and by 1.97-13.63x (using WFA-GPU)},
      html = {https://arxiv.org/abs/2309.17063},
      journal = {arXiv},
      abbr={arXiv},
      code = {https://github.com/CMU-SAFARI/GateSeeder},
      bibtex_show=true,
}

@article {Jahshan2023,
	author = {Zuher Jahshan and Itay Merlin and Esteban Garz{\'o}n and Leonid Yavits},
	title = {DASH-CAM: Dynamic Approximate SearcH Content Addressable Memory for genome classification},
	elocation-id = {2023.09.29.560142},
	year = {2023},
	month = {oct},
	doi = {10.1101/2023.09.29.560142},
	publisher = {Cold Spring Harbor Laboratory},
	abstract = {We propose a novel dynamic storage-based approximate search content addressable memory (DASH-CAM) for computational genomics applications, particularly for identification and classification of viral pathogens of epidemic significance. DASH-CAM provides 5.5x better density compared to state-of-the-art SRAM-based approximate search CAM. This allows using DASH-CAM as a portable classifier that can be applied to pathogen surveillance in low-quality field settings during pandemics, as well as to pathogen diagnostics at points of care. DASH-CAM approximate search capabilities allow a high level of flexibility when dealing with a variety of industrial sequencers with different error profiles. DASH-CAM achieves up to 30\% and 20\% higher F1 score when classifying DNA reads with 10\% error rate, compared to state-of-the-art DNA classification tools MetaCache-GPU and Kraken2 respectively. Simulated at 1GHz, DASH-CAM provides 1,178x and 1,040x average speedup over MetaCache-GPU and Kraken2 respectively.},
	URL = {https://www.biorxiv.org/content/early/2023/10/02/2023.09.29.560142},
        html = {https://www.biorxiv.org/content/early/2023/10/02/2023.09.29.560142},
	eprint = {https://www.biorxiv.org/content/early/2023/10/02/2023.09.29.560142.full.pdf},
	journal = {bioRxiv},
	abbr={bioRxiv},
        bibtex_show=true,
}

@inproceedings{firtina_rawhash_2023,
  booktitle={Proceedings of the 31st Annual Conference on Intelligent Systems for Molecular Biology (ISMB) and the 22nd European Conference on Computational Biology (ECCB)}, 
	title = {{RawHash}: {Enabling} {Fast} and {Accurate} {Real}-{Time} {Analysis} of {Raw} {Nanopore} {Signals} for {Large} {Genomes}},
	doi = {10.1093/bioinformatics/btad272},
  url = {https://arxiv.org/abs/2301.09200},
  html = {https://arxiv.org/abs/2301.09200},
	abstract = {Nanopore sequencers generate electrical raw signals in real-time while sequencing long genomic strands. These raw signals can be analyzed as they are generated, providing an opportunity for real-time genome analysis. An important feature of nanopore sequencing, Read Until, can eject strands from sequencers without fully sequencing them, which provides opportunities to computationally reduce the sequencing time and cost. However, existing works utilizing Read Until either 1) require powerful computational resources that may not be available for portable sequencers or 2) lack scalability for large genomes, rendering them inaccurate or ineffective.

We propose RawHash, the first mechanism that can accurately and efficiently perform real-time analysis of nanopore raw signals for large genomes using a hash-based similarity search. To enable this, RawHash ensures the signals corresponding to the same DNA content lead to the same hash value, regardless of the slight variations in these signals. RawHash achieves an accurate hash-based similarity search via an effective quantization of the raw signals such that signals corresponding to the same DNA content have the same quantized value and, subsequently, the same hash value.

We evaluate RawHash on three applications: 1) read mapping, 2) relative abundance estimation, and 3) contamination analysis. Our evaluations show that RawHash is the only tool that can provide high accuracy and high throughput for analyzing large genomes in real-time. When compared to the state-of-the-art techniques, UNCALLED and Sigmap, RawHash provides 1) 25.8x and 3.4x better average throughput and 2) significantly better accuracy for large genomes, respectively. Source code is available at https://github.com/CMUSAFARI/RawHash.},
	author = {Firtina, Can and Ghiasi, Nika Mansouri and Lindegger, Joel and Singh, Gagandeep and Cavlak, Meryem Banu and Mao, Haiyu and Mutlu, Onur},
	month = {jul},
	year = {2023},
  code={https://github.com/CMU-SAFARI/RawHash},
  abbr={ISMB/ECCB},
  bibtex_show=true,
}

@inproceedings{abecasis2023,
  booktitle={Proceedings of the 5th Workshop on Accelerator Architecture in Computational Biology and Bioinformatics (AACBB)}, 
	title = {{GAPiM}: a hardware acceleration of Genome Analysis pipeline using Processing in Memory},
	doi = {10.1101/2023.07.26.550623v1},
  url = {https://www.biorxiv.org/content/10.1101/2023.07.26.550623v1},
  html = {https://www.biorxiv.org/content/10.1101/2023.07.26.550623v1},
	abstract = {Variant calling is a fundamental stage in genome analysis that identifies mutations (variations) in a sequenced genome relative to a known reference genome. Pair-HMM is a key part of the variant calling algorithm and its most compute-intensive part. In recent years, Processing-in-Memory (PiM) solutions, which consist of placing compute capabilities near/inside memory, have been proposed to speed up the genome analysis pipeline. We implement the Pair-HMM algorithm on a commercial PiM platform developed by UPMEM. We modify the Pair-HMM algorithm to make it more suitable for PiM execution with acceptable loss of accuracy. We evaluate our implementation on single chromosomes and whole genome sequencing datasets, demonstrating up to 2x speedup compared to existing CPU accelerations and up to 3x speedup compared to FPGA accelerations.},
	author = {Abecassis, Naomie and G{\'o}mez-Luna, Juan and Mutlu, Onur and Ginosar, Ran and Moisson-Franckhauser, Aph{\'e}lie and Yavits, Leonid},
	month = {jun},
	year = {2023},
  code={https://github.com/naomieab/UPMEM_HAPLOTYPECALLER},
  abbr={AACBB},
  bibtex_show=true,
}


@inproceedings{mutlu2023accelerating,
  booktitle = {Proceedings of the 60th Design Automation Conference (DAC)},
  series = {{DAC} '23},
  title={Accelerating Genome Analysis via Algorithm-Architecture Co-Design},
  author={Mutlu, Onur and Firtina, Can},
  journal={arXiv preprint arXiv:2305.00492},
  doi = {10.48550/arXiv.2305.00492},
  url = {https://doi.org/10.48550/arXiv.2305.00492},
  abstract = {High-throughput sequencing (HTS) technologies have revolutionized the field of genomics, enabling rapid and cost-effective genome analysis for various applications. However, the increasing volume of genomic data generated by HTS technologies presents significant challenges for computational techniques to effectively analyze genomes. To address these challenges, several algorithm-architecture co-design works have been proposed, targeting different steps of the genome analysis pipeline. These works explore emerging technologies to provide fast, accurate, and low-power genome analysis.
This paper provides a brief review of the recent advancements in accelerating genome analysis, covering the opportunities and challenges associated with the acceleration of the key steps of the genome analysis pipeline. Our analysis highlights the importance of integrating multiple steps of genome analysis using suitable architectures to unlock significant performance improvements and reduce data movement and energy consumption. We conclude by emphasizing the need for novel strategies and techniques to address the growing demands of genomic data generation and analysis.},
  year={2023},
  month = jul,
  bibtex_show = true,
  html={https://doi.org/10.48550/arXiv.2305.00492},
  abbr={DAC}
}

@Article{Yavits2023,
  author = {Leonid Yavits},
  title  = {Will computing in memory become a new dawn of associative processors?},
  journal   = {{IEEE} J. Emerg. Sel. Topics Circuits Syst.},
  issn   = {2773-0646},
  pages  = {100033},
  volume = {4},
  doi    = {10.1016/j.memori.2023.100033},
  abstract = {Computer architecture faces an enormous challenge in recent years: while the demand for performance is constantly growing, the performance improvement of general-purpose CPU has almost stalled. Among the reasons are memory and power walls, due to which data transfer increasingly dominates computing. By significantly reducing data transfer, data-centric (or in-memory) computing promises to alleviate the memory and power walls. Associative processor is a non von Neumann computer invented in the 1960s but effectively cast aside until recently. It computes using associative memory in a perfect induction like fashion, using associative memory cells for both data storage and processing. Associative processor can be implemented using conventional CMOS as well as emerging memories. We show that associative processor can outperform state-of-the-art computing platforms by up to almost two orders of magnitude in a variety of data-intensive workloads.},
  bibtex_show = true,
  html={https://www.sciencedirect.com/science/article/pii/S2773064623000105},
  abbr={MMDCS},
  month           = jul,
  year={2023}
}

@inproceedings{gomez2023transpimlib,
  booktitle = {Proceedings of the 24th International Symposium on Performance Analysis of Systems and Software (ISPASS)},
  series = {{ISPASS} '23},
  title={TransPimLib: A Library for Efficient Transcendental Functions on Processing-in-Memory Systems},
  author={Item, Maurus and G{\'o}mez-Luna, Juan and Guo, Yuxin and Oliveira, Geraldo F and Sadrosadati, Mohammad and Mutlu, Onur},
  journal={arXiv preprint arXiv:2304.01951},
  doi = {10.48550/arXiv.2304.01951},
  url = {https://doi.org/10.48550/arXiv.2304.01951},
  abstract = {Processing-in-memory (PIM) promises to alleviate the data movement bottleneck in modern computing systems. However, current real-world PIM systems have the inherent disadvantage that their hardware is more constrained than in conventional processors (CPU, GPU), due to the difficulty and cost of building processing elements near or inside the memory. As a result, general-purpose PIM architectures support fairly limited instruction sets and struggle to execute complex operations such as transcendental functions and other hard-to-calculate operations (e.g., square root). These operations are particularly important for some modern workloads, e.g., activation functions in machine learning applications.
In order to provide support for transcendental (and other hard-to-calculate) functions in general-purpose PIM systems, we present \emph{TransPimLib}, a library that provides CORDIC-based and LUT-based methods for trigonometric functions, hyperbolic functions, exponentiation, logarithm, square root, etc. We develop an implementation of TransPimLib for the UPMEM PIM architecture and perform a thorough evaluation of TransPimLib's methods in terms of performance and accuracy, using microbenchmarks and three full workloads (Blackscholes, Sigmoid, Softmax). We open-source all our code and datasets at https://github.com/CMU-SAFARI/transpimlib.},
  bibtex_show = true,
  html={https://doi.org/10.48550/arXiv.2304.01951},
  abbr={ISPASS},
  month           = apr,
  year={2023}
}

@inproceedings{gomez2023evaluating,
  booktitle = {Proceedings of the 24th International Symposium on Performance Analysis of Systems and Software (ISPASS)},
  series = {{ISPASS} '23},
  title={Evaluating Machine Learning Workloads on Memory-Centric Computing Systems},
  author={G{\'o}mez-Luna, Juan and Guo, Yuxin and Brocard, Sylvan and Legriel, Julien and Cimadomo, Remy and Oliveira, Geraldo F and Singh, Gagandeep and Mutlu, Onur},
  journal={arXiv preprint arXiv:2207.07886},
  doi = {10.48550/arXiv.2207.07886},
  url = {https://doi.org/10.48550/arXiv.2207.07886},
  abstract = {Training machine learning (ML) algorithms is a computationally intensive process, which is frequently memory-bound due to repeatedly accessing large training datasets. As a result, processor-centric systems (e.g., CPU, GPU) suffer from costly data movement between memory units and processing units, which consumes large amounts of energy and execution cycles. Memory-centric computing systems, i.e., with processing-in-memory (PIM) capabilities, can alleviate this data movement bottleneck.
Our goal is to understand the potential of modern general-purpose PIM architectures to accelerate ML training. To do so, we (1) implement several representative classic ML algorithms (namely, linear regression, logistic regression, decision tree, K-Means clustering) on a real-world general-purpose PIM architecture, (2) rigorously evaluate and characterize them in terms of accuracy, performance and scaling, and (3) compare to their counterpart implementations on CPU and GPU. Our evaluation on a real memory-centric computing system with more than 2500 PIM cores shows that general-purpose PIM architectures can greatly accelerate memory-bound ML workloads, when the necessary operations and datatypes are natively supported by PIM hardware. For example, our PIM implementation of decision tree is 27x faster than a state-of-the-art CPU version on an 8-core Intel Xeon, and 1.34x faster than a state-of-the-art GPU version on an NVIDIA A100. Our K-Means clustering on PIM is 2.8x and 3.2x than state-of-the-art CPU and GPU versions, respectively.
To our knowledge, our work is the first one to evaluate ML training on a real-world PIM architecture. We conclude with key observations, takeaways, and recommendations that can inspire users of ML workloads, programmers of PIM architectures, and hardware designers & architects of future memory-centric computing systems.},
  bibtex_show = true,
  html={https://arxiv.org/abs/2207.07886},
  abbr={ISPASS},
  month           = apr,
  year={2023}
}

@Article{Lindegger2023,
  author          = {Lindegger, Joël and Cali, Damla Senol and Alser, Mohammed and Gómez-Luna, Juan and Ghiasi, Nika Mansouri and Mutlu, Onur},
  journal         = {Bioinformatics},
  title           = {Scrooge: A Fast and Memory-Frugal Genomic Sequence Aligner for {CPUs}, {GPUs}, and {ASICs}.},
  year            = {2023},
  issn            = {1367-4811},
  month           = mar,
  abstract        = {Pairwise sequence alignment is a very time-consuming step in common bioinformatics pipelines. Speeding up this step requires heuristics, efficient implementations, and/or hardware acceleration. A promising candidate for all of the above is the recently proposed GenASM algorithm. We identify and address three inefficiencies in the GenASM algorithm: it has a high amount of data movement, a large memory footprint, and does some unnecessary work. We propose Scrooge, a fast and memory-frugal genomic sequence aligner. Scrooge includes three novel algorithmic improvements which reduce the data movement, memory footprint, and the number of operations in the GenASM algorithm. We provide efficient open-source implementations of the Scrooge algorithm for CPUs and GPUs, which demonstrate the significant benefits of our algorithmic improvements. For long reads, the CPU version of Scrooge achieves a 20.1x, 1.7x, and 2.1x speedup over KSW2, Edlib, and a CPU implementation of GenASM, respectively. The GPU version of Scrooge achieves a 4.0x 80.4x, 6.8x, 12.6x and 5.9x speedup over the CPU version of Scrooge, KSW2, Edlib, Darwin-GPU, and a GPU implementation of GenASM, respectively. We estimate an ASIC implementation of Scrooge to use 3.6x less chip area and 2.1x less power than a GenASM ASIC while maintaining the same throughput. Further, we systematically analyze the throughput and accuracy behavior of GenASM and Scrooge under various configurations. As the best configuration of Scrooge depends on the computing platform, we make several observations that can help guide future implementations of Scrooge. https://github.com/CMU-SAFARI/Scrooge.},
  citation-subset = {IM},
  country         = {England},
  doi             = {10.1093/bioinformatics/btad151},
  issn-linking    = {1367-4803},
  nlm-id          = {9808944},
  owner           = {NLM},
  pii             = {btad151},
  pmid            = {36961334},
  pubmodel        = {Print-Electronic},
  pubstate        = {aheadofprint},
  revised         = {2023-03-24},
  bibtex_show = true,
  html={https://doi.org/10.1093/bioinformatics/btad151},
  abbr={Bioinformatics},
  year={2023}
}

@Article{Diab2023,
  author          = {Diab, Safaa and Nassereldine, Amir and Alser, Mohammed and Gómez Luna, Juan and Mutlu, Onur and El Hajj, Izzat},
  journal         = {Bioinformatics},
  title           = {A framework for high-throughput sequence alignment using real processing-in-memory systems.},
  issn            = {1367-4811},
  month           = mar,
  volume          = {39},
  abstract        = {Sequence alignment is a memory bound computation whose performance in modern systems is limited by the memory bandwidth bottleneck. Processing-in-memory (PIM) architectures alleviate this bottleneck by providing the memory with computing competencies. We propose Alignment-in-Memory (AIM), a framework for high-throughput sequence alignment using PIM, and evaluate it on UPMEM, the first publicly available general-purpose programmable PIM system. Our evaluation shows that a real PIM system can substantially outperform server-grade multi-threaded CPU systems running at full-scale when performing sequence alignment for a variety of algorithms, read lengths, and edit distance thresholds. We hope that our findings inspire more work on creating and accelerating bioinformatics algorithms for such real PIM systems. Our code is available at https://github.com/safaad/aim.},
  citation-subset = {IM},
  completed       = {2023-05-08},
  country         = {England},
  doi             = {10.1093/bioinformatics/btad155},
  issn-linking    = {1367-4803},
  issue           = {5},
  keywords        = {Sequence Alignment; Algorithms; Software; Computational Biology; Sequence Analysis, DNA; High-Throughput Nucleotide Sequencing},
  nlm-id          = {9808944},
  owner           = {NLM},
  pii             = {btad155},
  pmc             = {PMC10159653},
  pmid            = {36971586},
  pubmodel        = {Print},
  pubstate        = {ppublish},
  revised         = {2023-05-09},
  bibtex_show = true,
  html={https://doi.org/10.1093/bioinformatics/btad155},
  abbr={Bioinformatics},
  year={2023}
}

@Article{Garzon2023,
  author    = {Esteban Garz{\'{o}}n and Marco Lanuzza and Adam Teman and Leonid Yavits},
  journal   = {{IEEE} J. Emerg. Sel. Topics Circuits Syst.},
  title     = {AM4: {MRAM} Crossbar Based {CAM/TCAM/ACAM/AP} for In-Memory Computing},
  abstract  = {In-memory computing seeks to minimize data movement and alleviate the memory wall by computing in-situ, in the same place that the data is located. One of the key emerging technologies that promises to enable such computing-in-memory is spin-transfer torque magnetic tunnel junction (STT-MTJ). This paper proposes AM4, a combined STT-MTJ-based Content Addressable Memory (CAM), Ternary CAM (TCAM), approximate matching (similarity search) CAM (ACAM), and in-memory Associative Processor (AP) design, inspired by the recently announced Samsung MRAM crossbar. We demonstrate and evaluate the performance and energy-efficiency of the AM4-based AP using a variety of data intensive workloads. We show that an AM4-based AP outperforms state-of-the-art solutions both in performance (with the average speedup of about 10 x) and energy-efficiency (by about 60 x on average).},
  number    = {1},
  pages     = {408--421},
  volume    = {13},
  bibsource = {dblp computer science bibliography, https://dblp.org},
  biburl    = {https://dblp.org/rec/journals/esticas/GarzonLTY23.bib},
  doi       = {10.1109/JETCAS.2023.3243222},
  bibtex_show = true,
  html={https://ieeexplore.ieee.org/abstract/document/10040683},
  abbr={JETCAS},
  month           = mar,
  year={2023}
}

@article{firtina_blend_2023,
	title = {{BLEND}: a fast, memory-efficient and accurate mechanism to find fuzzy seed matches in genome analysis},
	volume = {5},
	url = {https://academic.oup.com/nargab/article/5/1/lqad004/6993940},
  html = {https://arxiv.org/abs/2112.08687},
    bibtex_show = true,
	doi = {10.1093/nargab/lqad004},
	abstract = {Generating the hash values of short subsequences, called seeds, enables quickly identifying similarities between genomic sequences by matching seeds with a single lookup of their hash values. However, these hash values can be used only for finding exact-matching seeds as the conventional hashing methods assign distinct hash values for different seeds, including highly similar seeds. Finding only exact-matching seeds causes either (i) increasing the use of the costly sequence alignment or (ii) limited sensitivity. We introduce BLEND, the first efficient and accurate mechanism that can identify both exact-matching and highly similar seeds with a single lookup of their hash values, called fuzzy seed matches. BLEND (i) utilizes a technique called SimHash, that can generate the same hash value for similar sets, and (ii) provides the proper mechanisms for using seeds as sets with the SimHash technique to find fuzzy seed matches efficiently. We show the benefits of BLEND when used in read overlapping and read mapping. For read overlapping, BLEND is faster by 2.4x–83.9x (on average 19.3x), has a lower memory footprint by 0.9x–14.1x (on average 3.8x), and finds higher quality overlaps leading to accurate de novo assemblies than the state-of-the-art tool, minimap2. For read mapping, BLEND is faster by 0.8x–4.1x (on average 1.7x) than minimap2. Source code is available at https://github.com/CMU-SAFARI/BLEND.},
	number = {1},
	journal = {NAR Genomics and Bioinformatics},
	author = {Firtina, Can and Park, Jisung and Alser, Mohammed and Kim, Jeremie S and Cali, Damla Senol and Shahroodi, Taha and Ghiasi, Nika Mansouri and Singh, Gagandeep and Kanellopoulos, Konstantinos and Alkan, Can and Mutlu, Onur},
	month = {mar},
	year = {2023},
	pages = {lqad004},
  code={https://github.com/CMU-SAFARI/BLEND},
  abbr={NARGAB},
}

@Article{Garzon2023a,
  author   = {Garzón, Esteban and Yavits, Leonid and Teman, Adam and Lanuzza, Marco},
  journal  = {Chips},
  title    = {Approximate Content-Addressable Memories: A Review},
  year     = {2023},
  issn     = {2674-0729},
  number   = {2},
  pages    = {70--82},
  volume   = {2},
  abstract = {Content-addressable memory (CAM) has been part of the memory market for more than five decades. CAM can carry out a single clock cycle lookup based on the content rather than an address. Thanks to this attractive feature, CAM is utilized in memory systems where a high-speed content lookup technique is required. However, typical CAM applications only support exact matching, as opposed to approximate matching, where a certain Hamming distance (several mismatching characters between a query pattern and the dataset stored in CAM) needs to be tolerated. Recent interest in approximate search has led to the development of new CAM-based alternatives, accelerating the processing of large data workloads in the realm of big data, genomics, and other data-intensive applications. In this review, we provide an overview of approximate CAM and describe its current and potential applications that would benefit from approximate search computing.},
  doi      = {10.3390/chips2020005},
  owner    = {calkan},
  url      = {https://www.mdpi.com/2674-0729/2/2/5},
  bibtex_show = true,
  html      = {https://www.mdpi.com/2674-0729/2/2/5},
  abbr = {Chips},
}

